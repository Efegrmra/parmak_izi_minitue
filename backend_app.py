# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Nsn6kmCOP581qLVfm4DJlQMF3iX3djaT
"""

import os, pathlib
from fastapi import FastAPI, UploadFile, File, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from dotenv import load_dotenv
from backend_utils import (
    ensure_tools, save_upload_to_tmp, nfseg_segment,
    mindtct_extract, nfiq2_score, bozorth3_score,
    create_all_minutiae_png_base64
)

load_dotenv()

# <--- YENİ YÜZDELİK HESAPLAMA AYARLARI --->
# Bu değerleri ayarlayarak yüzdelik hesabını kalibre edebilirsiniz.
# MIN_MATCH_THRESHOLD: Bu skorun altı %0 kabul edilir. 
# (Bozorth3 için 40 makul bir "eşleşme başladı" eşiğidir)
MIN_MATCH_THRESHOLD = 40.0

# MAX_SATURATION_SCORE: Bu skor ve üzeri %100 kabul edilir.
# (472'nin yüksek bir yüzde olması için 500 iyi bir tavan)
MAX_SATURATION_SCORE = 500.0 

def convert_bozorth_score_to_percentage(raw_score: int) -> float:
    """Bozorth3 ham skorunu 0-100 arası bir yüzdeye çevirir."""
    
    if raw_score < MIN_MATCH_THRESHOLD:
        # Eşiğin altındaysa, eşleşme %0'dır
        return 0.0

    if raw_score >= MAX_SATURATION_SCORE:
        # Belirlediğimiz tavanın üzerindeyse, eşleşme %100'dür
        return 100.0

    # Puanı min-max aralığından 0-100 aralığına ölçeklendir
    # Formül: (değer - min) / (max - min) * 100
    try:
        percentage = ((raw_score - MIN_MATCH_THRESHOLD) / (MAX_SATURATION_SCORE - MIN_MATCH_THRESHOLD)) * 100.0
        # Sonucu bir ondalık basamağa yuvarla (örn: 93.9)
        return round(percentage, 1)
    except ZeroDivisionError:
        # MIN ve MAX aynı ayarlanırsa bu olabilir, %100 döndür
        return 100.0
# <--- YENİ FONKSİYON SONU --->


app = FastAPI(title="NBIS Fingerprint Backend", version="1.0.0")

origins = (os.getenv("ALLOWED_ORIGINS") or "").split(",")
allow_all = any(o.strip() in ["*", ""] for o in origins)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"] if allow_all else [o.strip() for o in origins if o.strip()],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class CompareResponse(BaseModel):
    bozorth3_score: float  # <--- DEĞİŞTİ (int -> float)
    a_quality: dict | None = None
    b_quality: dict | None = None
    quality_summary: str | None = None
    a_png_b64: str | None = None
    b_png_b64: str | None = None

class AnalyzeResponse(BaseModel):
    nfiq2: dict | None = None
    notes: str | None = None

@app.get("/health")
def health():
    missing = ensure_tools()
    return {"status": "ok" if not missing else "degraded", "missing": missing}

@app.post("/analyze", response_model=AnalyzeResponse)
async def analyze(file: UploadFile = File(...), use_nfseg: bool = False):
    try:
        content = await file.read()
        suffix = pathlib.Path(file.filename).suffix or ".img"
        img_path = save_upload_to_tmp(content, suffix)
        seg_path = nfseg_segment(img_path, img_path + "_seg") if use_nfseg else img_path
        nfiq = nfiq2_score(seg_path)
        return AnalyzeResponse(nfiq2=nfiq, notes="Processed with nfseg" if use_nfseg else None)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/compare", response_model=CompareResponse)
async def compare(
    a: UploadFile | None = File(None),
    b: UploadFile | None = File(None),
    file1: UploadFile | None = File(None),
    file2: UploadFile | None = File(None),
    use_nfseg: bool = False,
    include_quality: bool = True,
):
    try:
        A = a or file1
        B = b or file2
        if not A or not B:
            raise HTTPException(status_code=400, detail="Two files are required: use fields 'a' and 'b' or 'file1' and 'file2'.")

        a_bytes = await A.read()
        b_bytes = await B.read()
        a_suffix = pathlib.Path(A.filename).suffix or ""
        b_suffix = pathlib.Path(B.filename).suffix or ""
        
        a_path = save_upload_to_tmp(a_bytes, a_suffix or ".wsq")
        b_path = save_upload_to_tmp(b_bytes, b_suffix or ".wsq")

        a_proc = nfseg_segment(a_path, a_path + "_seg") if use_nfseg else a_path
        b_proc = nfseg_segment(b_path, b_path + "_seg") if use_nfseg else b_path

        a_xyt = mindtct_extract(a_proc, a_proc + "_mindtct")
        b_xyt = mindtct_extract(b_proc, b_proc + "_mindtct")

        # <--- DEĞİŞİKLİK: Ham skoru al ve yüzdeye çevir --->
        raw_score, _ = bozorth3_score(a_xyt, b_xyt)
        percentage_score = convert_bozorth_score_to_percentage(raw_score)
        # <--- DEĞİŞİKLİK SONU --->

        a_q = nfiq2_score(a_proc) if include_quality else None
        b_q = nfiq2_score(b_proc) if include_quality else None

        qs = None
        try:
            if a_q and b_q:
                av = (float(str(a_q.get("score", 0))) + float(str(b_q.get("score", 0)))) / 2.0
                qs = f"avg NFIQ2 ≈ {av:.2f}"
        except Exception:
            pass
        
        a_b64 = create_all_minutiae_png_base64(a_bytes, a_suffix, a_xyt)
        b_b64 = create_all_minutiae_png_base64(b_bytes, b_suffix, b_xyt)

        return CompareResponse(
            bozorth3_score=percentage_score, # <--- DEĞİŞTİ (raw_score yerine yüzdelik skor)
            a_quality=a_q,
            b_quality=b_q,
            quality_summary=qs,
            a_png_b64=a_b64,
            b_png_b64=b_b64
        )
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
